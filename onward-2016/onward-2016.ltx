%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint,10pt]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{booktabs}
\usepackage{array}
\usepackage{amsbsy}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{listings}

%\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{2016}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{The Open Authorial Principle}        % These are ignored unless
\preprintfooter{The Open Authorial Principle}   % 'preprint' option specified.

\title{The Open Authorial Principle}
\subtitle{Supporting Networks of Authors in Creating Externalizable Designs}

\authorinfo{Name1}
           {Affiliation1}
           {Email1}
\authorinfo{Name2\and Name3}
           {Affiliation2/3}
           {Email2/3}

\maketitle
\begin{abstract}
We introduce a new principle, the {\it open authorial principle}, that characterises desirable properties of languages and configuration systems supporting networks of authors. We survey the growth in generosity of authorial systems, in a progression starting with traditional object-orientation, continuing with aspect-oriented, context-oriented, and dependency injection systems, and concluding with the most recent generation of ``freely dimensioned'' systems such as Korz and Fluid Infusion. We rework examples originally developed for Korz and Newspeak into Infusion's configuration system, and discuss how multiple authors can additively contribute fresh implementation dimensions into the same artefact, and how to resolve priority amongst their contributions. We show a working system that allows adaptations to be dynamically contributed into a video processing pipeline, and consider the implications of our principle for
the externalisation of application designs, resulting from the need to promote the representation of differences between programs as valid programs themselves.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%\terms
%term1, term2

\keywords
context awareness, declarative configuration

\section{Introduction}

{\it Reuse} is the capacity of a design to empower others to continue the design process via extension or adaption. Developments in programming idioms increasingly support this capacity in richer networks of authors working on artefacts with more complex structuring. In this paper, we will survey a series of increasingly generous idioms which we will categorise into a 4-level hierarchy according to the sophistication of the reuse stories that they support, starting with object-orientation at the base level 1. Our stories will be structured around authors through whose hands designs successively pass, conventionally labelled $A$, $B$, $C$, etc. in which collection an ``end user'' $E$ is morally incorporated. We'll assemble these authors into {\it networks} in which authors who exchange design artefacts are connected by arcs in the network. One example of such a connection is whereby $A$ writes source text that is processed by a compiler lying along the arc, resulting in an executable used by $B$. Another is if $A$ writes a base class which is imported by $B$ in order to produce a derived class by the addition of source text.

\subsection{Horizons in the network of authors}\label{sec:horizons}

We consider that all existing programming idioms create unwelcome distinctions among a population of authors, and thus, {\it horizons} beyond which the graph of authors cannot grow. Some authors can restructure the work of an originating author to enable the modifications they want. But other authors won't have this privilege. Even if they might in principle earn the right to make such modifications, as in an open source project, in practice they may lack the resources to do so. Thus the graph of authors fails to be {\it open} if a language system can't economically address each level of these reuse scenarios --- that is, to deliver the affordances of reuse at a cost that the interested community can afford. We'll consider that a system {\it de facto} fails to deliver these affordances economically if it incurs costs amongst the authors that grow much faster than linearly with respect to their number and the size of design they're collaborating on.

As we progress through increasingly sophisticated levels of reuse, we will observe that the horizon bounding the graph of authors is steadily pushed back. At level 2 we will meet developments such as Aspect-Oriented Programming \cite{Kiczales97} and Context-Oriented Programming \cite{Costanza05}, and at level 3 more modern and ambitious systems such as Newspeak \cite{Bracha10} and Korz \cite{Ungar14}. In order to situate the entire hierarchy of levels, showing the way to level 4 and beyond, we will summarise our conception of reuse under a central organising principle, our new {\it open authorial principle} (OAP). This principle provides a light in which the potential for any design idiom to promote generous reuse can be clearly assessed. The principle, elaborated in section \ref{sec:principle}, states 

\newtheorem*{principle}{Principle}

\begin{principle}[The Open Authorial Principle] Any expression by one author should allow its effect in the design to be replaced by an {\it additional} expression by a further author.
\end{principle}

%It's most important to note that $B$'s expression is additional to $A$'s in the design: it replaces $A$'s only in its effects, not in expression. In Meyer's terms (section \ref{sec:meyer}), $A$'s expression is {\it closed}.

\subsection{An algebra of program differences}\label{sec:algebraI}

The principle implies an unusual characteristic for the language system we are interested in, which is usually reserved only for artefacts as processed by the tooling systems that work on them, such as version control systems. The difference between two valid programs is typically named a {\it diff} or a {\it patch} in such systems, and is hardly ever a valid program in its own right. What we seek is a language or dialect in which representatives of such differences can be fairly compactly and validly encoded within the language itself.

This goal gives rise to what we will call an {\it algebra of program differences} in which expressions are combined. In section \ref{sec:addition} we will informally consider a {\it program addition operator} $\boldsymbol{\oplus}$ combining members of the algebra. This operator lies outside the space traditionally considered part of a programming language design. Our reuse goal implies refining the action of the operator by which program differences are combined. Our algebra cannot be operated with crude, unstable source-level coordinates such as program line numbers directing where differences are taken from and where they are projected to. We need to recast the work of programming in terms of a {\it natural coordinate system} in which units of design have meaningful, stable names which identify their location in a fine-grained tree of cells (section \ref{sec:dom}) within the design. This work has underlain the design of our system, Infusion, which offers level 4 reuse in our hierarchy and will be described in section \ref{sec:infusion}.

\subsection{Reuse levels}

The following sections will tour our hierarchy of reuse levels, an overview and illustrations of which appear in table \ref{fig:levels}. In this presentation of reuse levels, we'll try to use the term ``implementation unit'' rather than idiom-specific terminology such as ``object'', ``class'', ``module'', ``type'' etc.\ for naming units, to avoid biasing the discussion. 

\section{Meyerian Reuse - Level 1}\label{sec:meyer}

Meyer's open/closed principle \cite{Meyer88}\footnote{To paraphrase, ``A module should be available for extension ({\it open}) but also available for use ({\it closed})'' --- where Meyer connoted availability for use with the fact that a module's content should not be modifiable, promoting uses such as caching, verification, etc.}, codifies what is now accepted as one of the core principles of object-orientation. Meyer's principle allows for what could be described as ``first-order reuse''. One author can use the definition of an implementation unit to derive an elaborated definition without requiring the original author to modify their definition. This provides only for reuse of single implementation elements at a time (classes/objects), and does little to facilitate reuse across a design or of larger aggregations --- in fact, we will argue that object-orientation actively impedes such wider reuse.

In Meyer's presentation\footnote{We use Meyer as a standin for the much wider community sharing the same reuse model, such as the Smalltalk/Self communities tracing lineage to Kay and the mainstream Java/C++/C\# communities, etc.}, there are implicitly authors $A$, $B$, and (at least one) end user $E$. $A$ has created an implementation unit named $\alpha$. $B$ wishes to refine $\alpha$ to $\alpha'$, and share this with $E$ as a substitutable replacement for $\alpha$. $B$ is assisted in doing this by a feature of an object-oriented language granting the ability to create an artefact named a {\it base class} or {\it interface}\footnote{The presence of $\aleph$ is actually a detail arising from \cite{Martin96}'s re-presentation of Meyer's principle, but the two presentations are identical from the point of view of their authorial affordances for the OAP.} $\aleph$ (aleph) which expresses some of the content of the contract $A$ and $B$ advertise to $E$. When $E$'s use of $\alpha$ or $\alpha'$ is confined to the scope of $\aleph$, $B$'s modified code providing $\alpha'$ can be swapped for $A$'s providing $\alpha$ without $E$ needing to know about the change. This situation is illustrated in row 1 of table \ref{fig:levels}. Note that this swap can only be made if $E$ is using a $\alpha$ that already exists; their code can equally well use an $\alpha'$. But if $E$'s code creates an $\alpha$, it can't instead create an $\alpha'$ without being modified. Typical solutions in object-oriented frameworks to this problem of constructional dependency involve a variety of ``factory pattern'' \cite{Gamma94}. We will return to these when we start to treat more profound incarnations of reuse problems in the the following section \ref{sec:factory}.

\setlength{\extrarowheight}{3pt}

\begin{table*}[t]
\begin{center}
\makebox[\linewidth][c]{%
    \begin{tabular}{m{1.2cm}>{\raggedright}m{6cm}>{\raggedright}m{2.0cm}>{\raggedright}m{1.7cm}>{\raggedright\arraybackslash}m{6cm}}
      \toprule
      Level & Example Scenario & Systems Treating & Section & Diagram of Example Scenario\\
      \midrule
      Level 1 & A single artefact $\alpha$ created by A is extended to $\alpha'$ by B & Object Orientation & Section \ref{sec:meyer} & \includegraphics[width=1.5cm]{level1.png} \\
      Level 2 & A's $\alpha$ with a nested artefact $\beta$ has $\beta$ extended to $\beta'$ by B, creating an overall $\alpha'$ & Parameterised Types, AOP & Section \ref{sec:basic} & \includegraphics[width=3cm]{level2.png} \\
      Level 3 & B extends A's $\alpha$ to a collection of $\alpha_n$, C wants to extend all of $\alpha_n$ by $\alpha_C$ without work proportional to $n$ & Newspeak and AOP (wide hierarchy), Korz (all)& Section \ref{sec:demanding}, Section \ref{sec:level3}, Section \ref{sec:distributions} & \includegraphics[width=4cm]{level3.png} \\
      Level 4 & A has created an extended containment hierarchy, containing some scattered $\gamma$ at a deeply nested level. B, C etc.\ want to extend the entire hierarchy adjusting only some $\gamma$ to $\gamma'$, without work proportional to the size of the hierarchy & Infusion & Section \ref{sec:demanding}, Section \ref{sec:level4} & \includegraphics[width=6cm]{level4.png} \\
      \bottomrule
\end{tabular}%
}
\small
\caption{Table of levels of increasingly sophisticated reuse with illustrations}
\label{fig:levels}
\end{center}
\vspace*{-0.5cm}
\end{table*}

\section{A Basic Reuse Scenario - Level 2}\label{sec:basic}
In this section, we'll explore the most basic elaboration of the Meyerian (level 1) reuse scenario that exposes the limitations of object-orientation and other contemporary idioms. Author $A$ has created an implementation unit named $\alpha$ which contains a subunit named $\beta$. Author $B$ has refined $\beta$ to $\beta'$, and wants to create $\alpha'$ which is $\alpha$ with its $\beta$ replaced by $\beta'$. $B$ would like to share $\alpha'$ with author $E$ as a substitute for $\alpha$. This situation is illustrated in row 2 of table \ref{fig:levels}.

\subsection{Containment through aggregation}\label{sec:factory}

There are several possible embodiments of the ``containment'' relation here, even within the same idiom, which lead to somewhat different fates for $B$'s plan. Firstly, containment may be aggregation --- $\alpha$ is a class which has a member $b$ explicitly constructed of type $\beta$. In unadorned object-orientation, we are already out of luck. We have no way to modify the place in $\alpha$ where $b$ is declared, without simply rewriting the code.``Open to extension but closed for modification'' has failed. Some traditional responses to this problem apply a ``factory pattern'' --- the creation of an intermediary artefact we might name $\beth$ (beth) whose purpose is to abstract over the construction point of $\beta$. This is obviously unsatisfactory since we have a fresh class of entity --- factories --- to design in the system, in practice with its own type hierarchy to be maintained in parallel with the base artefacts --- as well as a wholly unmanageable ``regress'' problem of how the same reuse problem with respect to the factories is to be resolved. \cite{Bracha13} has commented on this form of pathology of ``design regress'', observing that it results when a ``shadow world'' is created as a result of resolving a problem with design artefacts that don't have a first-class design status. Other responses to this problem require a fresh language feature, orthogonal to the classically object-oriented ones, allowing the expression of ``parameterized'' or ``generic'' types --- we'll return to this possibility in section \ref{sec:inherit}.

\subsection{Containment through inheritance}\label{sec:inherit}

What if $A$ had already been applying Meyerian reuse and the containment-like relation between $\alpha$ and $\beta$ was already inheritance itself? With a simple use of implementation inheritance without overriding, we might say that $\alpha$ ``IS-A'' $\beta$ through including its entire definition into its own. $B$'s reuse requirement is now expressed as wanting an $\alpha'$ which is $\alpha$ with its base class $\beta$ replaced by $\beta'$. Unfortunately, this is an impossible form of reuse via the inheritance relation designed into traditional OO languages, and essentially forces the requirement for parameterised types to be added to the system. Parameterised types allow a definition to be generalised over all values of a type which appears in it.

\subsubsection{Reuse through parameterised types}\label{sec:templates}
In C++, author A, perhaps trying to address the reuse situation of section \ref{sec:inherit}, would have had to have {\it already written}

\begin{verbatim}
template <class beth> class alpha: public beth {}
\end{verbatim}

so that they themselves could then write

\begin{verbatim}
alpha<beta> myBeta;
\end{verbatim}

and that author B could write

\begin{verbatim}
alpha<beta1> myBeta1;
\end{verbatim}

Creating a template like this requires foresight from $A$: they need to anticipate that someone in their community may wish to modify $\beta$. It also adds complexity, as type signatures become longer and more involved. The name of an $\alpha$ cannot be mentioned without also bringing the requirement to mention the particular $\beth$ it involves. The requirement for this pattern of reuse was encountered very early in the lifetime of the C++ language and became characterised as the ``curiously recurring template pattern''\cite{Coplien95}.

An elegant solution to this ``foresight'' problem is comprised in solutions such as \cite{Bracha10}'s Newspeak, in which every type name is implicitly parameterised --- at every point of consuming a type name, a user has the facility to rebind it to one resolvable in their context. Newspeak resolves not only reuse problems at this level but also some at the following level 3.

Parameterised types are a sufficiently powerful reuse mechanism that they also resolve the aggregation variant of this problem in section \ref{sec:factory} --- it's just as easy for a parameterised type to appear as the type of a member as the type of a base class.

\subsubsection{Containment through private use}
Another possibility for the meaning of ``containment'' is that the point within $\alpha$ where $\beta$ is used lies simply within implementation code --- for example, the body of a method, and the $\beta$ instance does not appear within the class definition. This situation is yet worse than the one before, since we not only have to refactor $\alpha$ but also rewrite it to include some point where parameterisation by $\beth$ may be expressed.

\subsection{Aspect-Oriented Programming}

Aspect-oriented programming \cite{Kiczales97} is a solution to level 2 reuse problems which has appeared in some object-oriented languages --- most notably as a decoration to mainstream OO languages such as Java and C++. With AOP, author $B$ is allowed to create a symbolic expression known as a {\it joinpoint} to name the point in $A$’s design where $\beta$ is referred to. A further expression known as {\it advice} encodes the modification of the design where $\beta$ is substituted by $\beta'$. 

Whilst AOP provides a clear native solution to the level 2 reuse problems presented earlier in this section, it fails with the more demanding level 3 and 4 scenarios we will present in section \ref{sec:demanding}. The key limitation of AOP in these scenarios is that the aspects encoding joinpoints and advice can't be expressed in the base language. This means that modifications of these parts of a design can't be expressed using joinpoints and advice, but requires something new. That is, in the terminology where we elaborate the Open Authorial Principle in section \ref{sec:principle}, the space of AOP expressions {\it fails to be closed}. More primitive expressions of the same intent behind AOP are available in traditional OOP, under the names of ``decorator patterns'' or ``visitor patterns''\cite{Gamma94}. However, as well as suffering from the poor compositional properties of AOP\footnote{It is hard to decorate a decorator, since it has no clear coordinates in the design --- all one can do is add oneself to the list of decorators attached to the same base artefact.}, these also suffer from the same problem noted against templates in section \ref{sec:templates} --- they may not be deployed without design forethought.

\section{More Demanding Reuse Scenarios - Levels 3 and 4}\label{sec:demanding}

The simple scenario in section \ref{sec:basic}, solved by AOP, COP and similar formalisms, only represents level 2 reuse (with classic Meyerian inheritance solving the 1st-order scenario). In practice, much more demanding scenarios arise quite regularly. For example
\begin{itemize}
\item Level 3 reuse scenarios involve two authors, $B$ and $C$, both wishing to modify the same part (e.g. $\alpha$) of $A$'s work. While one response to this situation would be to require that $B$ and $C$ create completely separate versions of $A$'s work, this is clearly less desirable than an approach that allows these differing changes to be managed within a single framework. If $B$ and $C$ have to work with separate artefacts, they have become disconnected in the graph of authors. Thus a reuse facility for level 3 scenarios needs some way to manage multiple, potentially conflicting, modifications of the same structure.
%TODO: This sort of seems like the point at which "failure of closure" emerges but we should note that it also emerges at level 1->level2, from the requirement that the maker of a derived class needs to pick a new name which can't be constructionally or nestedly embedded, etc.
\item Level 4 reuse scenarios involve the location of the to-be-changed elements, $\gamma$s, within $A$'s work. If $\gamma$ occurs inside many layers of structure, introducing a template or other parameterisation point to support the modification will require a good deal of rework. Worse, if there are several $\gamma$s in $A$'s work, but only some of these should be changed, there may be no suitable point at which one can introduce a template. Such a scenario is illustrated in row 4 of table \ref{fig:levels}, and exampled in section \ref{sec:level4}. New facilities are needed to respond to these situations.
\end{itemize}

%[The point of required parameterisation may not correspond to a namable implementation unit (``type'', ``class'', etc.) of the host language - TODO - not an explicit reuse level but a ``quality of implementation'' issue much like avatarism]
\subsection{Refining Level 3 Reuse Scenarios}\label{sec:level3}
Note that level 3 reuse scenarios may be demanding on account of two orthogonal forces. The first force stresses designs where $B$ has extended $A$'s design into a deep hierarchy, and $C$ wishes to advise all of it. \cite{Bracha10} names this variety of level 3 reuse as the ``class hierarchy inheritance'' problem. In the formulation there (copied into our appendix \ref{sec:newspeaklisting}), author $A$ has created a base class {\tt Shape}, author $B$ a {\tt ShapeLibrary} deriving {\tt Rectangle}, {\tt Circle}, etc. and author $C$ has created a hierarchy of colorable things, and wishes to make all the contents of $B$'s library of shapes available to $E$ as coloured shapes without having to do work proportional to the size of the library. This situation is illustrated in row 3 of table \ref{fig:levels}, and we will return to it in section \ref{sec:distributions} where we work through an example from \cite{Bracha10}'s Newspeak. The second force stresses designs where there is a large number of authors, $C$, $D$ etc.\ all competing to extend the same artefact. \cite{Ungar14} names this variety of level 3 use as requiring ``symmetric dimensions of context'', and we will return to this scenario in section \ref{sec:context} where we work through an example from \cite{Ungar14}'s Korz.

%Want to mention that Korz deals with level 3 and that Newspeak probably deals with 3 and a part of 4 too - can't deal with the part of 4 unless these things have been given separate names at different points in the tree. Although it's not clear that Newspeak does allow reuse "from the outside" - you'd have to build up the whole tree again if you wanted to change a name at one part in it

\section{Reappraising Meyer's Principle}

Meyer's open/closed principle is a good foundation for ours. We believe in its primitives and ends --- especially in the possibility that an expression may be ``closed'' in the sense that it may be ``closed over'' by further authors as a result of being constant except in the face of genuine revisions to the overall program. This allows a form of ``referential transparency'' in design --- the use of the name of an implementation unit can be safely substituted for its referent, allowing for the possibility of caching, memoisation, etc. and similar desirable affordances. We see two fundamental limitations within Meyer's principle:

\begin{description}
\item[\small The need to account for composite structure in the reused artefacts] Meyer's formulation only refers to a single artefact at a time as being open or closed. As we discussed above in section \ref{sec:basic}, reuse scenarios can involve changes to multiple elements in a wider aggregate.
\item[\small The need to account for repeated reuse] Meyer's formulation only considers a single exercise of the faculty of reuse. In practice, creative networks spread wider, and the action of reuse should not degrade the potential for further reuse by more distant authors. This leads to our reformulation of the nature of {\it openness}.
\end{description}

\section{The Open Authorial Principle}\label{sec:principle}

Our reuse scenarios, characterised from levels 1-4 in the previous section, as well as a wider universe of uncharacterised scenarios, may be generalised by our Open Authorial Principle, as stated in section \ref{sec:horizons}:

\begin{quote}
\it Any expression from a member of the graph of authors can have its effect replaced (or removed) by the {\bf addition} of a further expression from any other member.
\end{quote}

This principle can be looked at from a different point of view in terms of the algebra of program differences mentioned in section \ref{sec:algebraI}. Many of our higher-level reuse scenarios require resolution of multiple sources of changes competing to modify the same site. The language of expressions, therefore, should give rise to an algebra that is closed under difference. That is, given any two programs, $\alpha$ and $\alpha_1$, that are similar in intention and expression, there should be a third program, $\delta_1$, such that combining $\alpha$ and $\delta_1$ produces a program that is identical in behavior (and close in its expression) to $\alpha_1$. An example appears in section \ref{sec:distributions}, where $\alpha$ consists of a shape, $\delta_1$ consists of the addition of a colour, and the resulting $\alpha_1$ represents a coloured shape. Should our language fail to meet a reuse scenario, we create a closed ``horizon'' in our graph of authors beyond which it cannot grow. Therefore an alternative statement of the OAP, which we'll elaborate in the next section, is as follows: 

\begin{quote}
\it What we seek is a {\it closed algebra of expressions} which will enable an {\it open graph of authors}.
\end{quote}

\subsection{The program addition operator $\boldsymbol{\oplus}$}\label{sec:addition}

We might write mathematically, describing the scenario of the previous section,
\begin{equation}
\forall \alpha, \alpha_1, \exists \delta_1 \text{\ s.t.\ } \alpha \boldsymbol{\oplus} \delta_1 = \alpha_1' \simeq \alpha_1
\end{equation}
where $\simeq$ represents two programs with the same behaviour, and $\boldsymbol{\oplus}$ represents the {\it program addition operator} which is used by authors in any network to combine programs together. Note that $\boldsymbol{\oplus}$ is rarely defined as part of a language definition, since its use more usually appears at the tooling level of a system. For example, in a compiled language, $\boldsymbol{\oplus}$ requires the addition of command-line arguments to the compiler, specifying source files which should be compiled together, whereas in JavaScript written for the web, $\boldsymbol{\oplus}$ requires the specification of {\tt <script>} tags at the head of the page referencing JavaScript source files which should be fetched and interpreted. It is a prerequisite for meeting the openness requirement that the system's facility for addressing $\boldsymbol{\oplus}$ should be available with respect to the particular form in which a program is delivered to a author in the network --- not likely if it was delivered in an executable binary form.

\cite{Gabriel12} observes that an important schism has opened up in the community between those working on ``systems'' and ``languages''. We observe that it will be impossible to meet the highest levels of reuse in languages which maintain this separation between semantics (studied by language theorists) and runtime behaviour (measured by the systems community). The protrusion of the program addition operator $\boldsymbol{\oplus}$ outside the space traditionally considered interesting by language theorists is an important evidence of this. Similar to CLOS, \cite{Gabriel12}'s paradigm example, a description of Infusion, our proposed language/system, will be impossible without also describing how to observe and influence a particular running system containing a program written with it\footnote{Further, following \cite{Gabriel12}, we observe that Infusion itself is a clear example of the engineering process preceding the scientific one, whilst still proceeding on a principled basis.}.

\subsection{This property cannot be provably or fully satisfied}

The property we seek is not susceptible to perfect verification, because it establishes properties observed by real users in real communities --- as explained in section \ref{sec:horizons}, the principle's subject matter is the economics of authorship rather than axiomatised theory. Not all differences among programs need to, or can, correspond to valid programs. Rather, the aim is that the majority of changes authors actually want to make should correspond to valid programs, and that these programs can be found without undue effort.

Can useful properties lie outside the domain of axiomatised theory? Consider homoiconicity, the property of a programming language in which the program structure is similar to its syntax. This is also a ``soft'' property: any language could be said to have it to at least some extent, LISP strongly and C very weakly. The notion is useful despite its not being crisp. The property is also not unrelated to the one we seek --- some measure of homoiconicity is clearly essential in a system capable of encoding program differences as programs.

% Remember to cite diff's "best efforts" nature and git diff's arbitrary nature
% Talk about the ADDITIVE OPERATOR and how it is another thing that "jumps out of the woodwork" that had always been implicit

\section{Fluid's Infusion System}\label{sec:infusion}

In this section we will describe the design and motivation of the {\it Infusion} configuration system, which has been under development in the Fluid community for some years. Many of Infusion's features were designed to support the OAP\footnote{In fact, the OAP only emerged partway through the design process of Infusion, as it became clear that a fundamental flaw in an older implementation (the one described in \cite{Basman11}) was that while apparently meeting all four levels of reuse, it still contained user expressions, {\it demands blocks}, which could not effectively be additively rewritten by others.}, but it also aims to meet many other needs (dataflow programming, live programming --- see \cite{Basman16}, literate programming, multi-paradigm collaborative authoring, etc.), which are outside the scope of this paper. 

We hesitate to name Infusion a language since it has been explicitly designed to omit several characteristics considered traditional amongst programming languages --- most notably that of being {\it Turing complete}. Our preferred designation for the class in which Infusion fits is an {\it integration domain} \cite{Kell09}. Infusion attempts to attack the the intractable space of language design by factoring the problem --- the comprehended part of the problem is described within Infusion's configuration system, expressed in a dialect of JSON, and the uncomprehended part, still requiring the expression of arbitrary programming language code, is left behind in the {\it base language} which is currently JavaScript\footnote{A misunderstanding of the nature of the OAP might allow one to pose the argument that basing Infusion on a dynamic language such as JavaScript substantially satisfies the OAP automatically. This argument is false, since the real economics of authorship don't support it --- whilst the in-memory representation of objects in a dynamic language is quite plastic, this goes little way towards helping users to find relevant objects at runtime and adapt them, preferably before their immediate clients start to consume them -- see section \ref{sec:basic} for examples. In practice, the economics of adaptation for ordinary dynamic languages run on the same basis as those for static languages --- locating the source code for the artefact, forking and modifying it.}. As the design of Infusion progresses, the balance shifts in favour of the former.

Infusion is used on a daily basis by software teams meeting real ends, and has comprehensive documentation available at \cite{Infusion17}.


\subsection{Infusion's problem domain} 
Infusion itself is not designed to permit the expression of arbitrary computations, and so there is by design a large variety of tasks to which it is unfitted. It could not be used to write a compiler, an operating system, or indeed even itself. The design space of Infusion is the space of {\it user programs} --- those which mediate some access to state on behalf of an end user, an ordinary member of society, through some form of user interface, most typically a visual one. Paradigm examples of this class of application are office applications or web applications.
We argue that what users require from such applications is not {\it computation} as traditionally conceived, but rather, coordinated access to some state in an appropriately context-dependent way.

\subsection{The constituents of an Infusion program}

Designs expressed in Infusion are structured, at runtime, into a single-rooted tree of implementation units (instances) named {\it components}. Each component takes its nature from one or more definitions named {\it grades}. A {\it grade} is a block of JSON configuration with a globally namespaced name. With a loose analogy, components and grades can respectively be corresponded to the objects and classes of an object-oriented design. We have chosen different names for our units to avoid confusing Infusion users with the very different behaviour and affordances of the related constructs in OO. Table \ref{fig:terms} shows a correspondence between some Infusion terms/primitives and these related concepts, together with some commentary on the differences in intention and expected benefits of the Infusion primitives.

Infusion grades more closely resemble ``mixins'' seen in some object-oriented traditions (for example, the Flavors/CLOS/etc. lineages discussed in \cite{Gabriel12}) than simple classes, since multiple grades may be listed for inheritance at each level of the hierarchy, and each may appear multiple times along the paths to root. An important difference in Infusion is that the results of grade resolution themselves take the form of a JSON document, a component's {\it merged options}, which are attached in immutable form to an instantiated component's top-level property named {\tt options}. This allows for the results of the merging and expansion process to be interpreted and consumed by other authors and tools in the system rather than simply the system's own runtime, and is an important example of Infusion widening the collection of privileged authors in the ecosystem, beyond the system's own compiler/interpreter, tools and runtime, a development motivated in \cite{Basman15}.

As well as simply coding for plain values, component options are interpreted by the runtime into specialised elements which are attached to the component on construction, such as events and their listeners, dataflow-driven models and constraints on these, bound functions (invokers), etc.\ which there is not room to describe here.

Ordinarily, multiple sources of component options are simply superimposed as JSON structures using an algorithm very similar to that seen in many popular utilities, for example, jQuery's {\tt extend} algorithm. However, the user can supply a {\tt mergePolicy} option to modify the process by which particular named options are collected and merged. We will see an example of this in our context adaptation sample in section \ref{sec:korz}.

\subsubsection{References and Distributions}

A component's merged options reflect more than just the options expressed in the hierarchical resolution process. In addition, options can be pulled in from the surrounding component tree by resolving {\it IoC references} (as shown in section \ref{sec:reference}) and also received from {\it options distributions} which allow options to be broadcast (pushed) out to other locations in the tree (seen in section \ref{sec:distributions}). IoC references fill some of the roles of a {\it linker} in other environments, which allow a design to be assembled from pieces which are then orchestrated into a complete program by ``fixing up'' symbolic references with respect to a context. Options distributions allow differences between programs to be represented as part of a program, which is the crucial requirement for our authorial principle (see section \ref{sec:principle}). These references represent the stable design coordinates described in section \ref{sec:algebraI}, a prerequisite for which is Infusion's encoding within a JSON tree with design-meaningful names as keys.

The aim of Infusion's resolution system is for references to resolve, even if from a conventionally object-oriented point of view they would result in a circular graph of references with respect to constructing objects. The Infusion runtime instantiates an entire component tree as part of a single, data-driven process, and only rejects graphs which are cyclic with respect to individual leaf values.

\setlength{\extrarowheight}{3pt}

\begin{table*}[t]
\vspace*{-0.3cm}
\begin{center}
\scriptsize
\makebox[\linewidth][c]{%
    \begin{tabular}{p{1.6cm}>{\raggedright}p{2.5cm}>{\raggedright}p{6cm}>{\raggedright\arraybackslash}p{6cm}}
      \toprule
      Term & Correlates & Distinction and Similarities & Intention and Advantages\\
      \midrule
      Grade & Type/Class & Rather than establishing {\it contracts} or describing {\it storage}, a grade is a block of (JSON) configuration with a globally-qualified name which is merged in an aligned way with others to produce a description from which component instances can be built. Grade names can also be used as {\it landmarks} ({\it context names}) in order to bind segments of IoCSS selectors. & The use of grade-based descriptions reduces {\it excess intention} \cite{Basman15} in descriptions of parts of implementations. The run-time structure of an instance is much more closely tied to the authoring-time structure, allowing for the ``notation'' of authors and users to be directly corresponded. \\
      Component & Object & Components are instances of grades, as objects are instances of classes. Rather than intending to {\it insulate} the implementation as a private implementation detail, the purpose of a component is to expose its contents (state, constants and tree of subcomponents) as directly and transparently as possible \cite{Clark17}. & The globally visible component tree in an Infusion system is the address space in which the design intentions of multiple authors can be expressed and coordinated. Options distributions could not be expressed if the space of their selectors could not be based on the already transparent address space of the component tree.\\
      Invoker & Method & Functions attached to Infusion components are coded for by declarative configuration defining {\it invokers}. Rather than the {\it dispatch} model used in object-orientation, where the identity of a requested member function (method) is computed dynamically based on the context of the callee, an execution of a particular invoker will always bind to the same function. & Static dispatch aids performance and clarity in a design, as well as correlating the behaviour of part of a design with that held in another system (an {\it avatar}) which may be based on different technologies. All the required benefits of context-awareness may be achieved by reinstantiating the part of a component tree affected by a contextual change\footnotemark. \\
      Model & Model (MVC Programming) / Model (Model-based development/MBD) / Behaviour (Functional Reactive Programming/FRP) & Infusion {\it models} encode mutable state in a JSON-equivalent form. Taken together with the associated model relay rules, these can constitute a model from the MBD point of view, since the space of model states can be deduced. Finally, the stream of values of a model over time can be compared to an FRP {\it behaviour}, transduced into other streams via transforming relay rules. & Similar to the use of grades, Infusion models minimise {\it divergence} between run-time and authoring structures. They also aid liveness and transportation of applications --- it should be possible to effectively move an application between systems or users by transmitting just its models. \\
      Options Distributions & Advice (AOP)/Diff (VCS) & An options distribution, like an aspect-oriented programming ``advice'', allows an existing application (component tree) to be modified by an author from the outside - that is, they can derive a variant application without modifying the expression of the original author. Unlike an advice, distributions have the same structure and syntax as ordinary configuration. & Since options distributions form a closed system, it is clear how multiple authors can collaborate on the same system, and multiple modifications competing to target the same piece of the design can have their relative priorities negotiated. This also implies that the same authoring tools can be used to write and check distributions as well as ordinary configuration. \\
      \bottomrule
\end{tabular}%
}
\small
\caption{Guide to terms used in this paper and relation to common forms}
\label{fig:terms}
\end{center}
\vspace*{-0.5cm}
\end{table*}

\subsection{A minimal Infusion program}\label{sec:minimal}

Listing \ref{fig:minimal} shows a minimal Infusion program. It registers a grade named {\tt examples.minimalGrade} derived from just the core framework grade {\tt fluid.component}, constructs an instance of it, and destroys it. Some implications of the explicit destruction lifecycle point triggered by {\tt destroy()} are discussed in section \ref{sec:lifecycle}.
\renewcommand{\tablename}{Listing}
\setcounter{table}{0}

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\small]
fluid.defaults("examples.minimalGrade", {
    gradeNames: "fluid.component"
});

var minimalInstance = examples.minimalGrade();
minimalInstance.destroy();
\end{Verbatim}
\vspace*{-0.2cm}
\caption{A minimal Infusion program}
\label{fig:minimal}
\end{center}
\vspace*{-0.6cm}
\end{table}

This example is expressed in JavaScript, which could suggest that the usage of Infusion is necessarily tied to the use of that language, but this is not the case. By means of the externalization provided by, for example, the \textbf{\textit{Nexus}} implemented as part of the GPII's Prosperity4All Program \cite{Nexus17}, all of the facilities used in listing \ref{fig:minimal} could be addressed from outside the process using standard HTTP endpoints. For example, the sequence of HTTP requests in listing \ref{fig:minimalNexus} would have the same effect as in listing \ref{fig:minimal}.

\begin{table}[t]
\begin{center}

\begin{Verbatim}[numbers=left,fontsize=\tiny]
HTTP PUT /defaults/examples.minimalGrade {gradeNames: "fluid.component"}
HTTP POST /components/minimalInstance {type: "examples.minimalGrade"}
HTTP DELETE /components/minimalInstance
\end{Verbatim}
\caption{Listing \ref{fig:minimal} issued over the Nexus HTTP protocol}
\label{fig:minimalNexus}
\end{center}
\vspace*{-0.6cm}
\end{table}

\subsection{A little Infusion program showing context-based reference}\label{sec:reference}

We move to a slightly higher level of complexity in order to exhibit how Infusion's context-based reference resolution system functions. In listing \ref{fig:minimalRef} we construct a small tree of three components, the root and two child components, {\tt monty} and {\tt rachael}, and a reference from the child {\tt monty} to a value held by the sibling {\tt rachael}. This shows Infusion's {\it structural scoping} model.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
fluid.defaults("examples.refRoot", {
    gradeNames: "fluid.component",
    components: {
        monty: {
            type: "fluid.component",
            options: {
                siblingAge: "{rachael}.options.age"
            }
        },
        rachael: {
            type: "fluid.component",
            options: {
                age: 42
            }
        }
    }
});

var that = examples.refRoot();
// Next line logs: "Resolved value via monty is 42"
console.log("Resolved value via monty is ", that.monty.options.siblingAge);
\end{Verbatim}
\caption{\footnotesize A small Infusion example showing reference resolution}
\label{fig:minimalRef}
\end{center}
\vspace*{-0.6cm}
\end{table}

An expression of the form {\tt \{rachael\}.options.age} as appearing at line 7 in listing \ref{fig:minimalRef} is known as an IoC reference, named after Infusion's role as an Inversion of Control framework. The portion {\tt \{rachael\}} of the reference is the {\it context expression}. In this form of reference, this matches upwards through the tree of instantiated components, looking for any parent or sibling of a parent matching the context name. A context name matches in three cases:
\begin{itemize}
\item It matches any full grade name that the component is derived from
\item It matches the last path segment of any grade name that the component is derived from
\item It matches the component's member name with which it is embedded in its containment parent
\end{itemize}
In our example, it is the 3rd rule which causes the reference to match the sibling on the member name {\tt rachael}. After the context part of the reference has matched, the remainder of the reference, e.g. {\tt options.age} is resolved by sequential property access on each path segment.
\vspace*{-0.05cm}
\section{Addressibility and Externalisability}\label{sec:address}
Following section \ref{sec:algebraI}, we now discuss two closely related properties of Infusion's design which we argue must emerge in a design or system that strongly satisfies the OAP. 

\begin{description}
\item[Free Addressibility] - Every part of every Infusion component can be referenced using a global path expression, encoding its path as descended from the global component tree root.
\item[Externalisability] - Infusion artefacts and state can be externalised naturally and directly --- aiding cooperation with artefacts in other languages and processes, for example by promoting the expression of avatars \cite{Clark17}.
\end{description}


\subsection{A New Cellular Model}\label{sec:dom}

The organisation of a Smalltalk application into insulated units named ``objects'' was inspired by the subdivision of biological entities into cells \cite{Kay03}. This is good engineering for systems which must be self-assembling and self-managing, but is a poor fit for systems which must place all of their resources for adaptability at the disposal of the user --- or a wider network of authors. Our cellular units are named ``components'', and rather than serving to insulate parts of the implementation one from the other, they serve the converse end of maximally advertising the structure of the application via a transparent addressing scheme. Infusion components have a further role in structuring an application, as their lifecycle points are used to structure the lifetimes of relationships and adaptations in the component tree.

Our inspiration is taken from a very popular and successful idiom for end-user programming --- the Document Object Model (DOM - \cite{W3C02}) mediating access to the rendered contents of web pages. A crucial affordance which has emerged from applications based on the DOM is the use of CSS selectors to stably represent selections of the tree of DOM nodes. The original use case for CSS selectors allowed
designers to target styling rules at parts of a web interface, which rules could expect some stability of reference as the content was designed. Over time, as web interfaces became more dynamic, CSS selectors became a vital part of the implementation design as well, as mediated by popular frameworks such as jQuery.

As a result of the DOM's huge currency at the core of the world's web browsers, DOM implementations have become extremely robust and performant platforms for shared authorship of a space of user interface elements, inspiring such implementations as \cite{Klokmose15}'s {\it Webstrates}, a collaborative authoring environment where the state of the DOM itself corresponds to the authorial shared state.

Our cellular model, thus, imports two vital elements from the idiom of DOM-based programming:

\subsubsection{Transparent, selector-based addressing}\label{sec:iocss}

A selection of tree nodes which is to be targeted with some effect or predicate can be stably identified by means of a pattern encoded into a string, with clauses representing intermediate match sites in the tree. In Infusion, our selector dialect is \textbf{\textit{IoCSS}}, named after one of the framework's original roles as an ``Inversion of Control'' system. It is structured very similarly to the CSS system, only with a greatly reduced set of predicates and combining rules. From the descendant selector rules of CSS we import only the descendant combinator consisting of whitespace, and the direct descendant rule $>$. For node selectors we allow just one possibility, a string matching contexts according to the rules of section \ref{sec:reference}, and the logical AND combinator $\&$.\footnotetext{for further details, see \cite{Basman16} for ``Queen of Sheba adaptation''.}

\subsubsection{Coordinated lifecycles with peers}\label{sec:lifecycle}

The DOM is an environment where elements may unpredictably come and go. It's crucial for application integrity that any effects associated with the existence of a node are banished along with its demise. A typical behaviour to maintain integrity is to in some form ``neuter'' such a destroyed element, so that it can no longer participate in making side effects visible to the user. In the DOM parlance, it is ``detached from the document'', and further operations with it remain valid, but can no longer influence the browser's rendering process. In Infusion, we act similarly, and prevent any further event listeners from being serviced on a component which has been destroyed. This is quite at odds with a typical OO approach, in which there is not intended to be any distinct lifecycle state in which an object reference is visible to referrers and in which the object is not considered ``live''. These lifecycle requirements go beyond those of traditional garbage collection because of the situation where a freshly destroyed node may {\it imminently} be targeted by an upcoming effect, say an event notification which is upcoming on the call stack.

In Infusion, there are yet more complex possibilities for multilateral relationships amongst component nodes. For example, one component may bind an event listener on behalf of another, set up a dataflow relationship between itself and other components, or broadcast options distributions into the tree at large. All of these relationships must be cleanly torn down when the component is destroyed.

The lifecycle of components also provides crucial landmarks in {\it time} whereby the scope of dynamic adaptations can be demarcated. We will see examples of this in our worked context awareness example in section \ref{sec:korz}.

\subsection{Externalisability and REST}\label{sec:rest}

A systematic failure of object-oriented environments is their tendency to be ``hermetic'' --- the semantic is defined in great detail of the behaviour of an implementation within a particular ``walled garden'' (the language itself and its virtual machine), and only limited thought is given to how this implementation is expected to coexist in a busy mixture of distributed elements written in a mixture of implementation technologies and idioms. The only common model for application distribution in the OO community is the ``proxy'' model, where a local agent (an ``object'') is considered to be a proxy for a remote one, fielding local messages, converting them into messages to the remote part of the system, awaiting a response and then issuing that response locally on behalf of the local client of the proxy. This is part and parcel of the ``message passing'' model of distribution on which object orientation is founded.

This model is sometimes highly appropriate --- especially when the messages passed are small and relatively infrequent, and/or the network has high bandwidth, reliability and low latency with respect to the application's requirements. However, it is not appropriate for applications where the throughput of such messages would be extremely high, or the application is extremely widely distributed over a collection of nodes joined by a network which is neither hugely reliable nor capacious. In section \ref{sec:60hz} we show an example of how an externalisable state idiom can eliminate a message passing linkage that would require untenable throughput.

As we identified in section \ref{sec:dom}, the web is a highly evolved and successful emergent architecture devoted to solving the problems of distributed application development, although it is frequently not recognised as such by computer scientists. The DOM idiom that we praise in section \ref{sec:dom} is part of a wider engineering idiom named REST by \cite{Fielding2000}. In this idiom, the response to a remote endpoint is not merely a message responding to an arbitrary query, but an exhaustive summary of the state of a {\it resource}. The acronym REST denotes {\it representational state transfer}, indicating that {\it state} is moved from place to place, rather than merely the answers to limited questions as with message passing. Infusion, similarly, places state (and not message passing) at its architectural core and facilitates architectures that work with it. 

Transferring application state in bulk (externalising sections of an application) has been noted by some authors as highly desirable for many authorial tasks --- for example, \cite{Kell12} notes that several changes in JVM design would be desirable in order to make it more ``observable'' for debugging purposes.

%Related to both of these areas comes Infusion's lack of {\it dispatch} --- Infusion does not have any concept of a {\it slot} or any kind of computed property access as is considered essential in most lineages of OO, especially those descended in the Smalltalk lineage. An Infusion component simply has concrete {\it members}, properties whose value at any time is straightforwardly derivable from looking into state by means of the base language's member access operator. 

\section{Infusion's options distributions}\label{sec:distributions}

{\it Options distributions} are the key feature through which Infusion designs enable the solution of level 4 reuse problems. They loosely correspond to {\it aspects} as seen in aspect-oriented programming systems, in that they allow a part of a design to be marked out for a change and ``advised'' in order to encode the change. As with all Infusion elements, these take the form of JSON-encoded options supplied to a grade. Each Infusion component may accept an options area named {\tt distributeOptions}, which may hold multiple, freely addressed distributions. Each distribution must contain an element {\tt target} encoding an IoCSS selector identifying, relative to the component's current location in the tree, where in the tree the distribution is to be targeted\footnote{The affordances of IoCSS selectors are a little reminiscent of XPath selectors\cite{W3C17} as hosted within XML Transformations (XSLT). We head off the unruly implications of such systems for maintenance by two main routes. Firstly, all Infusion configuration is immutable, composited into the running application by a merging algorithm which allows the {\it provenance} of all final configuration to be tracked back to its source user expression. Secondly, as opposed to XPath which is a programming language its own right, IoCSS selectors permit only the 4 primitives listed in section \ref{sec:iocss}.}. It must then include either an element {\tt record} holding literal options material to be distributed, or else an element {\tt source} holding a further IoCSS selector signifying that the distributed material should be sourced from existing material in the tree.

\subsection{A simple example showing an options distribution}
In listing \ref{fig:coloured} we show Newspeak's level 3 coloured shape example rendered in Infusion (as in the original sample, we'll omit the actual definitions of shapes, colours, etc.)

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
fluid.defaults("examples.shape", {
    gradeNames: "fluid.component",
... 
});
fluid.defaults("examples.shapeLibrary", {
    gradeNames: "fluid.component",
... 
});
fluid.defaults("examples.coloured", {
    gradeNames: "fluid.component",
... 
});
fluid.defaults("examples.colouredShapes", {
    gradeNames: "fluid.component",
    components: {
        colourizer: {
            type: "fluid.component",
            options: {
                distributeOptions: {
                    target: "{colouredShapes > shapeLibrary examples.shape}.options.gradeNames"
                    record: "examples.coloured"
                }
            }
        },
        shapeLibrary: {
            type: "examples.shapeLibrary",
            options: {
                components: {
                    shape: {
                        type: "examples.shape"
                    }
                }
            }
        }
    }
});

var that = examples.colouredShapes();
// Next line logs: "shapeLibrary's shape is coloured: true"
console.log("shapeLibrary's shape is coloured ", 
    fluid.componentHasGrade(that.shapeLibrary.shape, "examples.coloured"));
\end{Verbatim}
\vspace*{-0.2cm}
\caption{\small Options distribution in level 3 reuse Infusion sample}
\label{fig:coloured}
\end{center}
\vspace*{-0.7cm}
\end{table}

Here, author $C$'s expression is the component defined at line 16, and wishes to advise all shapes produced within author $B$'s {\tt shapeLibrary} hosted at line 25 that they should have the {\tt examples.coloured} grade mixed in to them. It does this by targetting via the IoCSS selector at line 20, whose effect reads, ``For all instances of {\tt examples.shape} nested anywhere below the {\tt shapeLibrary} held at the top level of containment in the overall {\tt colouredShapes} tree, contribute the grade name {\tt examples.coloured} to their grade list''.

\subsubsection{Options distributions as encoding of ``diff''s}\label{sec:diff}

It is through options distributions that differences between designs are encoded and transmitted around the system. The two parts of the IoCSS selector held in the {\tt target} field --- the context portion, and the path portion --- allow the {\it address} of the modified portion of the design to be compactly encoded. This means that diffs which should be small (for example, those that simply override a single deeply nested value in a single component) have small encodings. For encoding bigger differences, it is more economical for the author to package up a set of related changes to be made in a target component into a (possibly ad hoc) grade, and to distribute that grade name to an entire target component, rather than attempt to account for all the design changes individually. The use of a grade in this case increases the chances that a further author may in the future successfully reuse this difference itself in order to target it to make further changes. We'll see a real-world example of such a grade broadcast meeting a level 4 reuse problem in section \ref{sec:level4}.

%TODO Give example of non-grade distribution

\section{Freely Dimensioned Context Awareness}\label{sec:context}

Here we rework an example from the Korz system \cite{Ungar14} which demonstrated how fresh ``dimensions'' of adaptability can be contributed into a target artefact from multiple sources. This represents a high-order case of reusability (level 3 in terms of section \ref{sec:demanding}), and showing it in two systems will shed light on both systems as well as on the nature of reusability. Korz is a fertile ground for comparison, since its motivation takes a very similar initial line of argument to that supporting Infusion --- observing that object-orientation meets limited needs in contexts where only a single dimension of variation is in play, but needs to be extended to deal with realistic, extended designs involving multiple authors and dimensions.

Despite this similarity in fundamental argument, the resulting architectures of Korz and Infusion are extremely different. To start with, Korz can function as a general-purpose programming language, whilst Infusion cannot. Furthermore, the differences in the {\it dispatch model} of the two systems are profound. Korz is a language with highly dynamic dispatch, descended in a direct lineage from Smalltalk via the Self language and the Context Oriented Programming tradition \cite{Costanza05}, inheriting these languages' conceptions of ``slots'', named entries associated with an implementation unit where a runtime computation occurs in order to locate a particular implementation in response to a message. In contrast, Infusion has no dynamic dispatch whatsoever --- the dispatch choices to be made by an implementation unit (a {\it component}) are built into it at its point of instantiation. As we will see in our example, this lack of dynamic dispatch does not limit the dynamism of a runtime Infusion system, and in fact makes it easier to quantify and bound this dynamism and hence export it into other environments. In our example we will show how the dynamic content of part of an Infusion component tree can be exported into an environment traditionally very hostile to dynamism, the implementation of a WebGL shader operating a live filter of a video stream, written in the GLSL shader language.

\subsection{Context Adaptation Example}\label{sec:korz}

The example presented in \cite{Ungar14} demonstrates how fresh adaptations can be contributed to a target implementation, without either a change in its implementation or a change in the type name consumed by its users. This represents a modern, high level of adaptability, which is also present in such environments as Newspeak \cite{Bracha10}. We will work through this example using Infusion's {\tt contextAwareness} facility \cite{ContextAwareness17}.

The example application in \cite{Ungar14} represents a rendered image with an operation named {\tt drawPixel}, accepting three arguments, x and y coordinates and a colour pixel to be plotted at those coordinates' position. The user on whose behalf the image is to be rendered is considered to have some ``context'' accompanying them. The image rendering process should be modified by this context, in order to respond to the needs which the context implies. The examples provided in \cite{Ungar14} of such contextual requirements include:
\begin{itemize}
\item A ``colour blind'' user on whose behalf the image will be rendered in grayscale rather than in colour
\item An ``Australian'' user on whose behalf the image will be rendered upside down
\item A user from Antarctica on whose behalf the image should be rendered at double size as well as upside down
\end{itemize}

This example was crafted to exhibit that these contexts represent more or less ``orthogonal'' dimensions of adaptability for the target application, and that they are contributable to the target without interfering either with its implementation or unduly with each other. As examples of interactions \cite{Ungar14} consider a user who is both colour blind and an Australian, who should receive an image which is both grayscale and upside down, and also generalises the image inversion condition for Antarcticans and Australians to derive from the fact that they both belong to the ``Southern Hemisphere''. This structure of contextual adaptations, with multiple sources of context all competing to advise the same target implementation which must remain ``closed'' in the Meyerian sense marks out this example as an instance of level 3 reuse in our taxonomy of section \ref{sec:demanding}.

\subsection{Reworking this example in Infusion}

Our reworking of this example in Infusion\footnote{A live version of the application can be experimented with at \url{https://fluid-studios.github.io/infusion-onward-video-example}, and the full source code found in the source code held in the corresponding github repository.} will differ in many ways from the original sample. We will demonstrate a fully working application for the web, which will show the image rendering process applied to a full framerate video stream, in order to highlight design issues which emerge from treating extremely high-performance use cases which cannot be met without the use of specific external languages and technologies --- in this case, a ``shader'' written in the GLSL shader language of the HTML5 technology WebGL.

\subsubsection{State transfer in the application}\label{sec:60hz}

Following our discussion in section \ref{sec:rest} on state transfer, we will organise our application's adaptation functions not around an individual function call {\tt drawPixel} as in the original, but around the transfer of two matrices, one mapping the colour space of the renderer and one mapping the pixel space. There are strong practical as well as design incentives for this --- if rendering a 1080p video at 60Hz, our {\tt drawPixel} function would have to completely dispatch within 8ns even for a system fully saturating a core on this task, and we would naturally seek to defer to the GPU's own highly performant drawing loop rather than pushing it through an expensive dispatch process on the main core. 

\subsubsection{Factorising the example using context awareness}

Infusion contains dedicated features for handling context-aware scenarios of this type, involving the use of the framework grade {\tt fluid.contextAware} in the target component, allowing configuration to be built up in an options section named {\tt contextAwareness} by means of some framework utilities (e.g.\ {\tt fluid.contextAware.makeAdaptation}) and responding to context features marked to the current user by utilities such as {\tt\small fluid.contextAware.makeChecks} and {\tt\small fluid.contextAware.forgetChecks}. Full documentation is provided for these features at \cite{ContextAwareness17}. Note that all of these framework utilities represent ``user-mode'' convenience functions, which all factorise in practice down to Infusion primitive operations of the types seen in \ref{sec:minimal} --- that is, registration of defaults holding options distributions, construction and destruction of components --- they are thus equally well addressable over a remote HTTP Nexus API as seen in listing \ref{fig:minimalNexus} targeted at the runtime as well as over this local function call API.

On the JavaScript side we will maintain an ``avatar'' \cite{Clark17} representing the state of the rendering process in a component of type {\tt onward.imageRenderer} onto which we'll target our adaptations. Our adaptations will target the {\tt imageRenderer} with various additional mixin grades which will contribute matrices into its lists when certain contexts match. Part of the definition of the renderer is shown in listing \ref{fig:renderer} --- this encodes that it accepts two options named {\tt coordinateMatrix} and {\tt colourMatrix} which will simply be accumulated rather than merged during the options merging process. These give rise to two top-level options of the same names holding the accumulated matrix product of the constituent elements, by means of the expander definitions on lines 8-10\footnote{Expanders provide a means for Infusion configuration to be generated from function calls into the base language (JavaScript). These expanders are written in the ``compact syntax'' supported by Infusion as a syntactic sugar for the full JSON expander syntax. They are expanded to the JSON equivalents by a macro system before the system interprets them.}.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]

fluid.defaults("onward.imageRenderer", {
    gradeNames: ["fluid.component", "fluid.contextAware", "fluid.createOnContextChange"],
    mergePolicy: {
        coordinateMatrix: fluid.arrayConcatPolicy,
        colourMatrix: fluid.arrayConcatPolicy
    },
    coordinateMatrix: "@expand:onward.multiplyMatrices({that}.options.coordinateMatrix, \
        onward.mat2ToMat3)",
    colourMatrix: "@expand:onward.multiplyMatrices({that}.options.coordinateMatrix)"
});

onward.mat2toMat3 = function (mat2) {
    return [mat2[0], mat2[1], 0,  mat2[2], mat2[3], 0,   0, 0, 1];
};

onward.multiplyMatrices = function (matrices, transformSpec) {
    var transform = transformSpec ? fluid.getGlobalValue(transformSpec) : fluid.identity;
    return fluid.accumulate(function (accum, extra) {
        return mat3.multiply(accum, transform(extra));
    }, mat3.identity(mat3.create()));
};
\end{Verbatim}
\vspace*{-0.2cm}
\caption{Matrix accumulation for image renderer}
\label{fig:renderer}
\end{center}
\vspace*{-0.6cm}
\end{table}

Let's first deal with the ``southern Hemisphere'' family of adaptations --- a base context {\tt o.c.southernHemisphere} encoding the common inversion context, {\tt o.c.antarctic} which in addition encodes doubling of size, and {\tt o.c.australia} which simply derives from {\tt o.c.southernHemisphere}\footnote{First path segments {\tt onward.contexts} abbreviated to aid line breaking}. These adaptations appear in listing \ref{fig:hemisphere}.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
// Firstly, the context marker grades themselves
fluid.defaults("onward.contexts.southernHemisphere", {
    gradeNames: "fluid.component"
});
fluid.defaults("onward.contexts.antarctic", {
    gradeNames: "examples.contexts.southernHemisphere"
});
fluid.defaults("onward.contexts.australia", {
    gradeNames: "onward.contexts.southernHemisphere"
});

// Secondly the adaptations binding occurence of contexts onto renderer adaptations
fluid.contextAware.makeAdaptation({
    distributionName: "onward.adaptations.southernHemisphereInversion",
    targetName: "onward.imageRenderer",
    adaptationName: "yInversion",
    checkName: "southernHemisphere",
    record: {
        contextValue: "{onward.contexts.southernHemisphere}",
        gradeNames: "onward.rendererAdaptation.yInversion"
    }
});
fluid.contextAware.makeAdaptation({
    distributionName: "onward.adaptations.antarcticDoubling",
    targetName: "onward.imageRenderer",
    adaptationName: "scaleDoubling",
    adaptationPriority: "before:yInversion", // no effect - just for priority demonstration
    checkName: "antarctic",
    record: {
        contextValue: "{onward.contexts.antarctic}",
        gradeNames: "onward.rendererAdaptation.doubleScale"
    }
});

// Thirdly, the renderer adaptations
fluid.defaults("onward.rendererAdaptation.yInversion", {
    coordinateMatrix: [[1, 0], [0, -1]]
});

fluid.defaults("onward.rendererAdaptation.doubleScale", {
    coordinateMatrix: [[2, 0], [0, 2]]
});

\end{Verbatim}
\vspace*{-0.2cm}
\caption{Adaptations dealing with inversion and scaling for southern hemisphere}
\label{fig:hemisphere}
\end{center}
\vspace*{-0.6cm}
\end{table}

Line 27 shows how to arbitrate priority between adaptations, when needed. It's not actually needed here given the way we have encoded these adaptations, since all of the adaptation matrices commute. Note that whilst our definitions are significantly more verbose than the Korz equivalents, they are a little more cognitively economic since we don't need to reiterate both the scaling and inversion components of the mapping as in the Korz example of specialization for the Antarctic user which is shown in line 3 of listing \ref{fig:antarctic}. The complete listing of \cite{Ungar14}'s Korz code for this sample appears in appendix \ref{sec:korzlisting}.

\begin{table}[t]
\vspace*{-0.3cm}
\begin{center}
\begin{lstlisting}[numbers=left,basicstyle=\scriptsize\ttfamily,mathescape]
method { rcvr $\le$ screenParent, location $\le$ antarctica }
drawPixel(x, y, c) {
    {-location}.drawPixel(2 * x, -2 * y, c);
}
\end{lstlisting}
\vspace*{-0.2cm}
\caption{Korz slot definition for Antarctic user}
\label{fig:antarctic}
\end{center}
\vspace*{-0.6cm}
\end{table}

The listing \ref{fig:colourblind} shows the adaptations for the user who is colour blind.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
fluid.contextAware.makeAdaptation({
    distributionName: "onward.adaptations.colourBlindMonochrome",
    targetName: "onward.imageRenderer",
    adaptationName: "colourAdaptation",
    checkName: "colourBlind",
    record: {
        contextValue: "{onward.contexts.colourBlind}",
        gradeNames: "onward.rendererAdaptation.monochrone"
    }
});

// Standard luma coefficients from https://en.wikipedia.org/wiki/Luma_(video)
fluid.registerNamespace("onward.constants");
onward.constants.lumaRow = [0.2126, 0.7152, 0.0722];

fluid.defaults("onward.rendererAdaptation.monochrome", {
    colourMatrix: [
        onward.constants.lumaRow, 
        onward.constants.lumaRow,
        onward.constants.lumaRow
    ]
});
\end{Verbatim}
\vspace*{-0.2cm}
\caption{Colourblind/monochrome adaptations}
\label{fig:colourblind}
\end{center}
\vspace*{-0.6cm}
\end{table}

\subsubsection{Commentary on the sample}

Our rendition of this sample is substantially more verbose than the Korz treatment. Firstly, this results from Infusion's lack of syntax. Encoding Infusion primitives as JSON increases their verbosity greatly. However, this directly serves several of our ends: firstly, the ecosystem of tools consuming and producing these artefacts is much simplified.

Secondly, much of our verbosity stems from the extra names which our definitions are decorated with. For example, each adaptation block includes not only a {\tt distributionName} but also an {\tt adaptationName} and {\tt checkName}. These additional names directly serve the aims of the OAP, in ensuring that the authorial landscape is left with sufficient landmarks for further authors to bind on to, at each level of granularity. The {\tt adaptationName} can be targeted with a priority-based expression by further adaptations, indicating which adaptation should defer to which other, and the {\tt distributionName} can be used to identify the distribution itself in a running system in order for it to be overridden. Existing treatments of Korz, for example, don't specify the following scenarios:

\begin{itemize}
\item The disposition when multiple definitions are received with apparently identical guard conditions --- does a later definition displace an earlier, and how are ambiguities resolved with respect to minor mismatches in condition wording or aliases in term names?
\item How the author might arrange for the situation where a slot specification with fewer guard conditions is required to take priority over one with a greater number (the opposite of the semantic built in to the language's design)
\end{itemize}

Giving each such definition in the system a unique name is essential to allowing these contextually-guarded definitions themselves a first-class authorial status and ensuring that our algebra of expressions remains closed.

Another substantial difference between Korz and Infusion is that, whilst Infusion is {\it symmetric} (in terms of establishing symmetry between multiple authors allocating context dimensions), it is not {\it subjective}. Each observer of a particular assemblage of components will see exactly the same state and behaviour. This seems essential to us in order to make it clear how a particular part of the system should be externalized in order to represent it in another system. \cite{Ungar14} doesn't fully specify how contextual information should be attached to the observer and tracked, suggesting that it might be associated with the call stack. We consider this might be hard to manage when the interaction is part of one or many long-running asynchronous processes involving interactions stemming from multiple users. We suggest that a structural scoping model, where particular areas of the component tree are stably associated with interaction on behalf of different users in different contexts, would lead to clearer, more performant and more easily externalised designs.

We should observe that what passes between the portions of the system written in different languages (Infusion/JavaScript and GLSL) is nothing specially bound to a particular language system or Infusion specifically --- it is a collection of matrices in a straightforward encoding. This situation, where Infusion ends up as the gatekeeper for material representing some publicly encoded {\it lenses} rather than simply a broker for message passing, is quite typical, and such lenses form frequently encountered material in Infusion designs --- see \cite{Basman15}.

Finally, we should observe that whilst our example is capable of processing high-resolution video at framerate on everyday equipment, the space of adaptations of our version of the sample is much smaller than the Korz original. We are only able to make adaptations which are {\it linear} in the colour and coordinate spaces, whereas the Korz example can perform arbitrary functional mappings. 

\section{A Real-World Example of Type 4 Reuse}\label{sec:level4}

The Global Public Inclusive Infrastructure (GPII - \cite{Vanderheiden11}) is an ambitious project whose aim is to implement an auto-personalisation system makingt the resources of operating system and application-level adaptation available to users across all applications and platforms. 
%This aims to deliver, for example, context-sensitive and user-aware adaptations similar to our image rendering sample of section \ref{sec:korz}, across all applications capable of enacting or providing user interface adaptation.

A core GPII architectural component is the {\tt flowManager} \cite{FlowManager17} which assembles the user's preferences, the capabilities of a local device and relevant privacy policies, and orchestrates the device's capabilities to bring it to an inferred condition meeting the preferences. 

We analyse the network of authors who collaborated on the design of {\tt flowManager}s in terms of the OAP. The initial design by author $A$ implemented a ``local {\tt flowManager}'' which was simply hosted on the user's machine. Author $B$ extended $A$'s design to incorporate a remote ``cloudBased {\tt flowManager}'' to factor off just those functions which were relevant within the cloud. Author $C$ then aggregated together the designs of authors $A$ and $B$ to create a composite ``untrusted {\tt flowManager}" in order to meet freshly characterised privacy concerns, and needed to direct overriding configuration simply at $B$'s portion of the design, whilst leaving $A$'s untouched. We should stress that this still represents an architecture only at modest rather than extreme scale, currently comprising thousands rather than millions of lines of code. Therefore we feel justified in positioning even level 4 reuse as a standard, everyday level of reusability that every competent architecture should aspire to. In listing \ref{fig:gpii} we see a section of author $C$'s configuration.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
{
  type: "untrusted.development.all.local",
  options: {
    gradeNames: "kettle.multiConfig.config",
...
      distributeOptions: {
        "untrusted.development.port": {
          record: 8088,
          target: "{that cloudBasedConfig}.options.mainServerPort"
        },
        "untrusted.development.prefs": {
          record: "http://localhost:8088/preferences/%userToken",
          target: "{that cloudBasedConfig flowManager preferencesDataSource}.options.url",
          priority: "after:flowManager.development.prefs"
      },
...
  }
}
\end{Verbatim}
\vspace*{-0.25cm}
\caption{\footnotesize GPII FlowManager configuration showing level 4 reuse}
\label{fig:gpii}
\end{center}
\vspace*{-0.7cm}
\end{table}

On line 12, an IoCSS selector with 4 components {\tt\scriptsize \{that cloudBasedConfig flowManager preferencesDataSource\}} selects by path a particular subcomponent of just the remote {\tt flowManager} component for ``advice''. This full specification is necessary because in this configuration, {\it two} such instances exist along different containment paths, representing the traditionally local and remote functions of the system, and we wish to advise only one of them. This clearly represents level 4 reuse, since in a traditionally constructed system, the ``substitutability'' of these two instances via inheritance the {\tt gpii.flowManager} base grade would require work proportional to the size of the total design in order to resolve. Using this IoCSS selector, one author is able to compactly specify a ``diff'' (see section \ref{sec:diff}) with respect to the design of another, whilst leaving the original design unmodified. Note that, as in our context-aware sample of section \ref{sec:korz}, these authors are obliged to continually issue fresh names to keep pace with their rate of creating fresh surfaces for adaptation.

As a result of this, the design now stands ready for affordable 4th and 5th-order reuse: A further author, a mid-level integrator $D$ of the GPII, will aggregate a distribution from components representing a particular set of use cases, and a yet further author $E$ will derive a further distribution from this aggregation, whilst specifying that a deeply nested (and without a means such as IoCSS, hard to name) component should have a specially configured value. This is done whilst still leaving the field relatively uncluttered for yet further integrators to appear, and in their turn make further configurations, possibly overriding yet again the choices of $E$. 

We have a truly open authorial graph.

\section{Conclusion}

We have presented a tower of increasingly sophisticated scenarios of reuse, stretching from classical object-orientation's reuse at level 1 as ``Meyerian Reuse'' up to more demanding requirements characterised as level 4, which we argue represent everyday levels of reuse that arise routinely in real architectures. We've argued that the key to eliminating horizons in the graph of authors is to allow program differences to be freely expressed and combined as programs. This expression gives rise to the fundamentally different architectural strategies informing the design of Fluid's Infusion system. These strategies also promote more natural externalisation of designs, supporting more straightforward interactions with external systems implemented in different processes, languages and idioms.

We have exhibited the Open Authorial Principle, which summarises the requirements of all 4 levels of this tower as well as encompassing a much wider terrain of as yet unarticulated reuse capabilities. Meeting this principle well requires iterated cycles of implementation, self-observation and refinement, steadily increasing the range of expressions which the principle can subsume in a realistic space of user designs. We devote ourselves to this struggle.

%mention indirect assistance from idiom - rest, etc. as well as direct language supports

\appendix

\section{Appendix}
Program listings extracted from papers referenced in this work.
\subsection{Dimensional Adaptation in Korz}\label{sec:korzlisting}

In section \ref{sec:context} we rework an example from \cite{Ungar14} exhibiting freely dimensioned context awareness. In listing \ref{fig:korzlisting} we reproduce the original Korz language version as seen in \cite{Ungar14}:

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
def {} pointParent = newCoord;
def {} point = newCoord extending pointParent;

var {rcvr ≤ point} x;
var {rcvr ≤ point} y;
var {rcvr ≤ point} color;

method {
    rcvr ≤ pointParent, 
    device //dimension required but can be anything
}
display {
    device.drawPixel(x, y, color) 
};

def {} screenParent = newCoord;
def {} screen = newCoord extending screenParent;
method {rcvr ≤ screenParent} drawPixel(x, y, color) { 
// draw the pixel in the color 
}

def {} locationParent = newCoord;
def {} location = newCoord extending locationParent;
def {} southernHemi = newCoord extending location;
def {} australia = newCoord extending southernHemi;
def {} antarctica = newCoord extending southernHemi;


method { rcvr ≤ screenParent, isColorblind ≤ true }
drawPixel(x, y, c) {
    {isColorblind: false}
        .drawPixel(x, y, c.mapToGrayScale)
}

method { rcvr ≤ screenParent, location ≤ southernHemi }
drawPixel(x, y, c) {
    { -location }.drawPixel(x, -y, c)
}

method {
    rcvr ≤ screenParent,
    isColorblind ≤ true, 
    location ≤ southernHemi
}
drawPixel(x, y, c) {
    {-isColorblind}.drawPixel(x, y, c.mapToGrayScale);
}

method { rcvr ≤ screenParent, location ≤ antarctica }
drawPixel(x, y, c) {
    {-location}.drawPixel(2 * x, -2 * y, c);
}
\end{Verbatim}
\vspace*{-0.25cm}
\caption{\footnotesize Multidimensional adaptation sample in Korz, extracted from \cite{Ungar14}}
\label{fig:korzlisting}
\end{center}
\vspace*{-0.7cm}
\end{table}

\subsection{Class Hierarchy Inheritance in Newspeak}\label{sec:newspeaklisting}

In section \ref{sec:distributions} we rework an example from \cite{Bracha13} exhibiting what is there named class hierarchy inheritance. In listing \ref{fig:newspeaklisting} we reproduce the original Newspeak language version as seen in \cite{Bracha13}.

\begin{table}[t]
\begin{center}
\begin{Verbatim}[numbers=left,fontsize=\tiny]
class ShapeLibrary usingPlatform: platform = (
    | ”We use = to define immutable slots”.
    private List = platform collections List.
    private Error = platform exceptions Error.
    private Point = platform graphics Point.
|
)
(
    public class Shape = (...)(...)
    public class Circle = Shape (...)(...)
    public class Rectangle = Shape (...)(...)
)

class ExtendShapes withShapes: shapes = (
    | ShapeLibrary = shapes. |
)(
    public class ColorShapeLibrary usingPlatform: platform =
        ShapeLibrary usingPlatform: platform (
    )(
        public class Shape = super Shape ( | color | )(...)
    )
)
\end{Verbatim}
\vspace*{-0.25cm}
\caption{\footnotesize Class hierarchy inheritance sample in Newspeak, extracted from \cite{Bracha13}}
\label{fig:newspeaklisting}
\end{center}
\vspace*{-0.7cm}
\end{table}

%\acks

%Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Basman(2016)]{Basman16}
Antranig Basman, Luke Church, Clemens Klokmose, Colin Clark {\it Software and How it Lives On -- Embedding Live Programs in the World Around Them}, Proceedings of the 27th Annual PPIG Workshop, 2016.

\bibitem[Basman(2015)]{Basman15}
Antranig Basman, Colin Clark and Clayton Lewis {\it Harmonious Authorship from Different Representations}, Proceedings of the 26th Annual PPIG Workshop, 2015

\bibitem[Basman(2011)]{Basman11}
Antranig Basman, Clayton Lewis, and Colin Clark {\it 
To Inclusive Design through Contextually Extended IoC}, Proceedings of the ACM OOPSLA Companion (Wavefront), 2011.

\bibitem[Bracha(2013)]{Bracha13}
Gilad Bracha {\it A DOMain of Shadows}, blog posting at \url{http://gbracha.blogspot.co.uk/2014/09/a-domain-of-shadows.html}

\bibitem[Bracha(2010)]{Bracha10}
Gilad Bracha, Peter von der Ah\'e, Vassili Bykov, Yaron Kashai, William Maddox and Eliot Miranda {\it Modules as Objects in Newspeak}. Proceedings of the 24th ECOOP, June 21-25 2010. Springer Verlag LNCS 2010.

\bibitem[Clark(2017)]{Clark17}
Colin Clark and Antranig Basman {\it Tracing a Paradigm for Externalization: Avatars and the GPII Nexus}, $\langle$Programming$\rangle$, Proceedings of  Salon des Refus\'es Workshop, 2017.

\bibitem[Coplien(1995)]{Coplien95}
James O. Coplien {\it Curiously Recurring Template Patterns} C++ Report: 24--27, 1995.

\bibitem[Costanza(2005)]{Costanza05}
Pascal Costanza and Robert Hirschfeld {\it Language Constructs for Context-oriented Programming: an Overview of ContextL}, in: DLS'05: Proceedings of the 2005 Symposium on Dynamic Languages, ACM, New York, NY, USA, pages 1–10, 2005.

\bibitem[W3C(2002)]{W3C02}
Philippe Le H\'egaret. ``The W3C Document Object Model (DOM)''. World Wide Web Consortium, 2002 \url{http://www.w3.org/2002/07/26-dom-article.html}

\bibitem[Fielding(2000)]{Fielding2000}
Roy T. Fielding {\it Architectural Styles and the Design of Network-based Software Architectures}, PhD thesis, University of California, Irvine, 2000.

\bibitem[Gabriel(2012)]{Gabriel12}
Richard P. Gabriel {\it The structure of a programming language revolution}, Proceedings of the ACM Onward 2012, pages 195-214. Springer NY 2012.

\bibitem[Gamma(1994)]{Gamma94}
Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm {\it Design Patterns: Elements of Reusable Object-Oriented Software}, Addison-Wesley, 1994

\bibitem[Nexus(2017)]{Nexus17}
GPII Team {\it The GPII Nexus}, \url{https://wiki.gpii.net/w/The_Nexus}, 2017.

\bibitem[FlowManager(2017)]{FlowManager17}
GPII Team {\it The GPII FlowManager}, \url{https://wiki.gpii.net/w/Flow_Manager}, 2017

\bibitem[Fluid Team(2017)]{Infusion17}
Fluid Team {\it Fluid Infusion Documentation}, \url{http://docs.fluidproject.org/infusion/development/}, 2017.

\bibitem[ContextAwareness(2017)]{ContextAwareness17}
Fluid Infusion Documentation on ContextAwareness feature \url{http://docs.fluidproject.org/infusion/development/ContextAwareness.html}, 2017.

\bibitem[Kay(2003)]{Kay03}
Alan Kay {\it ``E-Mail of 2003-07-23''. Dr. Alan Kay on the Meaning of ``Object-Oriented Programming''.} \url{http://www.purl.org/stefan_ram/pub/doc_kay_oop_en}

\bibitem[Kiczales(1997)]{Kiczales97}
Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina Videira Lopes, Jean-Marc Loingtier and John Irwin {\it Aspect-oriented programming}. Proceedings of the 11th ECOOP (1997).

\bibitem[Kell(2009)]{Kell09}
Stephen Kell {\it The mythical matched modules: overcoming the tyranny of inflexible software construction}, Proceedings of the 2009 OOPSLA Companion (Onward), pages 881-888, ACM.

\bibitem[Kell(2012)]{Kell12}
Stephen Kell, Danilo Ansaloni, Walter Binder and Luk\'a\u{s} Marek {\it The JVM is not observable enough (and what to do about it)}, Proceedings of the VMIL '12, pages 33-38, ACM, New York.

\bibitem[Klokmose(2015)]{Klokmose15}
Clemens N. Klokmose, James R. Eagan, Siemen Baader, Wendy Mackay and Michel Beaudouin-Lafon {\it Webstrates: Shareable Dynamic Media}, Proceedings of the 2015 UIST, pages 280-290, ACM, New York.

\bibitem[Martin(1996)]{Martin96}
Robert C. Martin {\it The Open-Closed Principle}, C++ Report, January 1996

\bibitem[Meyer(1988)]{Meyer88}
Bertrand Meyer {\it Object-Oriented Software Construction}, Prentice-Hall, 1988

\bibitem[Parnas(1972)]{Parnas72}
David L. Parnas {\it On the Criteria to be Used in Decomposing Systems into Modules}, Communications of the ACM 15 (12) pp 1053-58, ACM, New York, December 1972

\bibitem[Ungar(2014)]{Ungar14}
David Ungar, Harold Ossher and Doug Kimelman {\it Korz: Simple, Symmetric, Subjective, Context-Oriented Programming}, Proceedings of the Fourth Symposium on New Ideas in Programming and Reflections on Software (Onward), ACM, 2014

\bibitem[Vanderheiden(2011)]{Vanderheiden11}
Gregg Vanderheiden and Jutta Treviranus {\it Creating  a Global Public Inclusive Infrastructure}. Universal Access in Human-Computer Interaction --- Design for All and eInclusion, pages 517-526. Berlin: Springer, 2011.

\bibitem[W3C(2017)]{W3C17}
W3C {\it XML Path Language (XPath) 3.1} W3C Recommentation 21 March 2017.

\end{thebibliography}
\end{document}
